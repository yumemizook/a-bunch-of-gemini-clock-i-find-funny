<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ancient Sundial & Wonders</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Cinzel+Decorative&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --parchment: #f0e6d2;
            --ink: #2c1810;
            --gold: #c5a059;
            --gold-glow: #ffd700;
            --stone: #8a8a8a;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Cinzel', serif;
            color: var(--parchment);
        }

        /* Background Landscape Canvas */
        #world-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Foreground Weather Effects Canvas (Rain on top of UI) */
        #weather-fx-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
        }

        /* UI Overlay Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
        }

        /* Header Info */
        .info-panel {
            margin-top: 2rem;
            text-align: center;
            background: rgba(44, 24, 16, 0.85);
            padding: 1rem 3rem;
            border: 2px solid var(--gold);
            border-radius: 8px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            pointer-events: auto;
            min-width: 320px;
        }

        .info-panel h1 {
            margin: 0;
            font-size: 2.5rem;
            color: var(--gold);
            font-family: 'Cinzel Decorative', serif;
            letter-spacing: 2px;
            text-shadow: 2px 2px 0px #000;
        }

        #greeting-display {
            font-size: 1.2rem;
            color: var(--parchment);
            margin: 0.5rem 0;
            letter-spacing: 1px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        /* Tooltip Styles */
        #ancient-tooltip {
            position: absolute;
            background: rgba(44, 24, 16, 0.95);
            color: var(--gold);
            padding: 8px 12px;
            border: 1px solid var(--gold);
            border-radius: 4px;
            font-family: 'Cinzel', serif;
            font-size: 16px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            transform: translate(-50%, -120%);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.8);
            white-space: nowrap;
        }

        /* Hoverable Elements */
        .hoverable {
            cursor: help;
            transition: fill 0.2s, color 0.2s;
        }

        .hoverable:hover {
            fill: var(--gold-glow) !important;
            color: var(--gold-glow) !important;
        }

        /* 3D Container for Instruments */
        .instruments-container {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 20px;
            margin-bottom: -50px;
            pointer-events: auto;
            transform-style: preserve-3d;
            transform: perspective(1000px) rotateX(40deg) scale(0.8);
            filter: drop-shadow(0px 40px 30px rgba(0, 0, 0, 0.8));
            transition: filter 1s ease;
        }

        .sundial-wrapper {
            position: relative;
            width: 380px;
            height: 380px;
        }

        .date-stone-wrapper {
            position: relative;
            width: 200px;
            height: 280px;
        }

        .oracle-wrapper {
            position: relative;
            width: 200px;
            height: 250px;
        }

        .temp-wrapper {
            position: relative;
            width: 100px;
            height: 280px;
        }

        svg {
            width: 100%;
            height: 100%;
            overflow: visible;
        }

        /* Date Stone Text */
        .date-month {
            font-family: 'Cinzel Decorative', serif;
            font-size: 24px;
            fill: #5d4037;
            text-anchor: middle;
            font-weight: bold;
        }

        .date-day {
            font-family: 'Cinzel', serif;
            font-size: 55px;
            fill: #3e2723;
            text-anchor: middle;
            font-weight: bold;
            filter: drop-shadow(1px 1px 0px rgba(255, 255, 255, 0.2));
        }

        .date-year {
            font-family: 'Cinzel', serif;
            font-size: 18px;
            fill: #5d4037;
            text-anchor: middle;
        }

        .engraving {
            fill: none;
            stroke: #8d6e63;
            stroke-width: 2;
            opacity: 0.6;
        }

        /* Sundial Specifics */
        .sundial-face {
            fill: url(#stoneGradient);
            stroke: #4a3b2a;
            stroke-width: 6;
        }

        .sundial-marks {
            stroke: #3e2723;
            stroke-width: 3;
            stroke-linecap: round;
        }

        .sundial-numerals {
            font-family: 'Cinzel', serif;
            font-size: 24px;
            fill: #2c1810;
            text-anchor: middle;
            dominant-baseline: middle;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .sundial-numerals.active-hour {
            fill: #8b0000;
            font-size: 28px;
            text-shadow: 0px 0px 5px rgba(255, 215, 0, 0.6);
        }

        .shadow-group {
            transform-origin: 190px 190px;
            transition: transform 0.1s linear;
            will-change: transform;
        }

        .shadow {
            fill: rgba(10, 5, 0, 0.85);
            mix-blend-mode: multiply;
        }

        /* Oracle Specifics */
        .oracle-bowl {
            fill: #3e2723;
            stroke: #2c1810;
            stroke-width: 2;
        }

        .oracle-liquid {
            transition: fill 1s ease, opacity 1s ease;
        }

        .oracle-text {
            font-family: 'Cinzel', serif;
            font-size: 18px;
            fill: #ffd700;
            text-anchor: middle;
            letter-spacing: 2px;
        }

        .oracle-temp {
            font-family: 'Cinzel', serif;
            font-size: 14px;
            fill: #dccdb2;
            text-anchor: middle;
        }

        /* Temp Specifics */
        .temp-tube {
            fill: rgba(255, 255, 255, 0.2);
            stroke: #8d6e63;
            stroke-width: 2;
        }

        .temp-liquid {
            transition: height 1s ease, y 1s ease, fill 1s ease;
        }

        /* Animations */
        @keyframes ripple {
            0% {
                r: 0;
                opacity: 0.8;
                stroke-width: 2;
            }

            100% {
                r: 60;
                opacity: 0;
                stroke-width: 0;
            }
        }

        .ripple-circle {
            fill: none;
            stroke: #fff;
            animation: ripple 2s infinite linear;
            display: none;
        }

        @keyframes mist {
            0% {
                transform: translateX(-10px);
                opacity: 0.3;
            }

            50% {
                transform: translateX(10px);
                opacity: 0.6;
            }

            100% {
                transform: translateX(-10px);
                opacity: 0.3;
            }
        }

        .mist-layer {
            fill: url(#mistGradient);
            animation: mist 5s infinite ease-in-out;
            display: none;
        }

        @media (max-width: 1000px) {
            .instruments-container {
                flex-wrap: wrap;
                /* Allow wrapping on small screens */
                gap: 30px;
                transform: perspective(800px) rotateX(20deg) scale(0.7);
                margin-bottom: 20px;
            }

            .sundial-wrapper {
                order: 1;
                margin: 0 20px;
            }

            .date-stone-wrapper {
                order: 2;
            }

            .oracle-wrapper {
                order: 3;
            }

            .temp-wrapper {
                order: 4;
            }
        }
    </style>
</head>

<body>

    <!-- Background Landscape -->
    <canvas id="world-canvas"></canvas>

    <!-- Foreground Weather Effects -->
    <canvas id="weather-fx-canvas"></canvas>

    <div id="ancient-tooltip">Translation</div>

    <div id="ui-layer">
        <div class="info-panel">
            <h1 id="clock-display">00:00:00</h1>
            <div id="greeting-display"></div>
            <div id="status-msg" style="color:#dccdb2; font-size: 0.9em; margin-top:5px;"></div>
        </div>

        <div class="instruments-container">
            <!-- DATE STONE (Calendar) -->
            <div class="date-stone-wrapper">
                <svg viewBox="0 0 220 300">
                    <defs>
                        <filter id="stoneNoise">
                            <feTurbulence type="fractalNoise" baseFrequency="0.7" numOctaves="3" stitchTiles="stitch" />
                            <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.1 0" />
                            <feBlend in="SourceGraphic" mode="multiply" />
                        </filter>
                    </defs>

                    <rect x="0" y="0" width="220" height="300" fill="#dccdb2" filter="url(#stoneNoise)" />
                    <rect x="15" y="15" width="190" height="270" class="engraving" rx="2" />
                    <circle cx="110" cy="150" r="90" class="engraving" opacity="0.3" />

                    <!-- Month Moved Up (y=55) -->
                    <text id="cal-month" x="110" y="55" class="date-month hoverable">IVNIVS</text>
                    <text id="cal-day" x="110" y="170" class="date-day hoverable">XIV</text>
                    <!-- Year Moved Down (y=270) -->
                    <text id="cal-year" x="110" y="270" class="date-year hoverable">MMXXIV</text>
                </svg>
            </div>

            <!-- SUNDIAL -->
            <div class="sundial-wrapper">
                <svg id="sundial-svg" viewBox="0 0 380 380">
                    <defs>
                        <radialGradient id="stoneGradient" cx="50%" cy="50%" r="50%" fx="40%" fy="40%">
                            <stop offset="0%" style="stop-color:#fdfbf7;stop-opacity:1" />
                            <stop offset="85%" style="stop-color:#dccdb2;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#8d6e63;stop-opacity:1" />
                        </radialGradient>
                        <filter id="shadow-blur">
                            <feGaussianBlur in="SourceGraphic" stdDeviation="2" />
                        </filter>
                    </defs>

                    <circle cx="190" cy="190" r="180" class="sundial-face" filter="url(#stoneNoise)" />
                    <circle cx="190" cy="190" r="160" fill="none" stroke="#2c1810" stroke-width="1" opacity="0.3" />

                    <g id="shadow-container" class="shadow-group">
                        <path id="sun-shadow" d="M190,190 L186,340 L194,340 Z" class="shadow"
                            filter="url(#shadow-blur)" />
                    </g>

                    <path d="M190,150 L185,190 L195,190 Z" fill="#2c1810" />
                    <circle cx="190" cy="190" r="6" fill="#3e2723" stroke="#1a0f0a" />
                </svg>
            </div>

            <!-- ORACLE BOWL (Weather) -->
            <div class="oracle-wrapper">
                <svg viewBox="0 0 200 250">
                    <defs>
                        <radialGradient id="liquidGold" cx="50%" cy="50%" r="50%" fx="50%" fy="40%">
                            <stop offset="0%" style="stop-color:#fff176;stop-opacity:0.9" />
                            <stop offset="100%" style="stop-color:#fbc02d;stop-opacity:0.9" />
                        </radialGradient>
                        <radialGradient id="liquidBlue" cx="50%" cy="50%" r="50%" fx="50%" fy="40%">
                            <stop offset="0%" style="stop-color:#81d4fa;stop-opacity:0.9" />
                            <stop offset="100%" style="stop-color:#0288d1;stop-opacity:0.9" />
                        </radialGradient>
                        <radialGradient id="liquidGrey" cx="50%" cy="50%" r="50%" fx="50%" fy="40%">
                            <stop offset="0%" style="stop-color:#cfd8dc;stop-opacity:0.9" />
                            <stop offset="100%" style="stop-color:#546e7a;stop-opacity:0.9" />
                        </radialGradient>
                        <linearGradient id="mistGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#fff;stop-opacity:0" />
                            <stop offset="50%" style="stop-color:#fff;stop-opacity:0.4" />
                            <stop offset="100%" style="stop-color:#fff;stop-opacity:0" />
                        </linearGradient>
                    </defs>

                    <!-- Tripod Legs -->
                    <path d="M30,100 L10,240 L25,240 L45,100 Z" fill="#3e2723" />
                    <path d="M170,100 L190,240 L175,240 L155,100 Z" fill="#3e2723" />
                    <path d="M100,100 L100,240" stroke="#3e2723" stroke-width="15" />

                    <!-- The Bowl -->
                    <path d="M20,100 Q100,200 180,100" fill="#2c1810" />
                    <ellipse cx="100" cy="100" rx="80" ry="15" class="oracle-bowl" />

                    <!-- Liquid Surface -->
                    <ellipse id="oracle-liquid" cx="100" cy="100" rx="70" ry="10" fill="url(#liquidGold)"
                        class="oracle-liquid" />

                    <!-- Animations -->
                    <circle id="rain-ripple" cx="100" cy="100" r="5" class="ripple-circle" />
                    <rect id="mist-overlay" x="50" y="80" width="100" height="40" class="mist-layer" />

                    <!-- Text below -->
                    <text id="oracle-status" x="100" y="210" class="oracle-text hoverable">SOLIS</text>
                    <text id="oracle-temp" x="100" y="230" class="oracle-temp">-- 째C</text>
                </svg>
            </div>

            <!-- PILLAR OF HEAT (Thermometer) -->
            <div class="temp-wrapper">
                <svg viewBox="0 0 100 280">
                    <defs>
                        <linearGradient id="tempGradientCold" x1="0%" y1="100%" x2="0%" y2="0%">
                            <stop offset="0%" style="stop-color:#0288d1" />
                            <stop offset="100%" style="stop-color:#b3e5fc" />
                        </linearGradient>
                        <linearGradient id="tempGradientHot" x1="0%" y1="100%" x2="0%" y2="0%">
                            <stop offset="0%" style="stop-color:#d32f2f" />
                            <stop offset="100%" style="stop-color:#ffeb3b" />
                        </linearGradient>
                    </defs>

                    <!-- Stone Base -->
                    <rect x="10" y="250" width="80" height="30" fill="#dccdb2" filter="url(#stoneNoise)" />
                    <path d="M20,250 L20,30 L80,30 L80,250 Z" fill="rgba(44, 24, 16, 0.4)" stroke="#8d6e63"
                        stroke-width="4" />

                    <!-- Glass Tube -->
                    <rect x="40" y="40" width="20" height="200" class="temp-tube" rx="10" />

                    <!-- Liquid Column -->
                    <rect id="temp-liquid" x="42" y="235" width="16" height="0" fill="#d32f2f" rx="8"
                        class="temp-liquid hoverable" />

                    <!-- Bulb at bottom -->
                    <circle cx="50" cy="240" r="18" fill="#8d6e63" />
                    <circle id="temp-bulb" cx="50" cy="240" r="12" fill="#d32f2f" class="temp-liquid" />
                </svg>
            </div>
        </div>
    </div>

    <script>
        // --- CONSTANTS ---
        const ROMAN_MONTHS = [
            "IANVARIVS", "FEBRVARIVS", "MARTIVS", "APRILIS", "MAIVS", "IVNIVS",
            "IVLIVS", "AVGVSTVS", "SEPTEMBER", "OCTOBER", "NOVEMBER", "DECEMBER"
        ];

        const WEATHER_MAP = {
            "0": { code: "SOLIS", type: "Clear", fill: "url(#liquidGold)" },
            "1": { code: "SOLIS", type: "Clear", fill: "url(#liquidGold)" },
            "2": { code: "NUBES", type: "Cloudy", fill: "url(#liquidGrey)" },
            "3": { code: "NUBES", type: "Cloudy", fill: "url(#liquidGrey)" },
            "45": { code: "NEBULA", type: "Fog", fill: "url(#liquidGrey)" },
            "48": { code: "NEBULA", type: "Fog", fill: "url(#liquidGrey)" },
            "51": { code: "IMBER", type: "Rain", fill: "url(#liquidBlue)" },
            "53": { code: "IMBER", type: "Rain", fill: "url(#liquidBlue)" },
            "55": { code: "IMBER", type: "Rain", fill: "url(#liquidBlue)" },
            "61": { code: "PLUVIA", type: "Rain", fill: "url(#liquidBlue)" },
            "63": { code: "PLUVIA", type: "Rain", fill: "url(#liquidBlue)" },
            "65": { code: "PLUVIA", type: "Rain", fill: "url(#liquidBlue)" },
            "71": { code: "NIX", type: "Snow", fill: "#eceff1" },
            "73": { code: "NIX", type: "Snow", fill: "#eceff1" },
            "75": { code: "NIX", type: "Snow", fill: "#eceff1" },
            "80": { code: "IMBER", type: "Rain", fill: "url(#liquidBlue)" },
            "81": { code: "IMBER", type: "Rain", fill: "url(#liquidBlue)" },
            "82": { code: "IMBER", type: "Rain", fill: "url(#liquidBlue)" },
            "95": { code: "FULMEN", type: "Storm", fill: "#4527a0" },
            "96": { code: "FULMEN", type: "Storm", fill: "#4527a0" },
            "99": { code: "FULMEN", type: "Storm", fill: "#4527a0" },
        };

        function toRoman(num) {
            if (typeof num !== 'number') return false;
            var digits = String(+num).split(""),
                key = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM",
                    "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC",
                    "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"],
                roman = "",
                i = 3;
            while (i--)
                roman = (key[+digits.pop() + (i * 10)] || "") + roman;
            return Array(+digits.join("") + 1).join("M") + roman;
        }

        // --- ENGINE STATE ---
        const canvas = document.getElementById('world-canvas');
        const ctx = canvas.getContext('2d');

        const fxCanvas = document.getElementById('weather-fx-canvas');
        const fxCtx = fxCanvas.getContext('2d');

        const state = {
            width: 0, height: 0,
            time: new Date(),
            weather: { condition: 'Clear', temp: 0, isDay: true, code: 0 },
            stars: [],
            clouds: [],
            birds: [],
            torches: [],
            households: [],
            rainDrops: [],
            sunPos: { x: 0, y: 0 },
            sunTimes: { rise: null, set: null }
        };

        let hourElements = [];

        // --- INIT ---
        window.onload = function () {
            resize();
            initStars();
            initClouds();
            initBirds();
            initTorches();
            initHouseholds();
            generateSundialMarks();

            fetchWeather();
            setInterval(fetchWeather, 1200000); // 20 mins refresh

            enableTooltips();
            gameLoop();
        };

        window.addEventListener('resize', resize);
        function resize() {
            state.width = window.innerWidth;
            state.height = window.innerHeight;
            canvas.width = state.width;
            canvas.height = state.height;
            fxCanvas.width = state.width;
            fxCanvas.height = state.height;
            initStars();
            initHouseholds();
        }

        // --- TOOLTIP LOGIC ---
        function enableTooltips() {
            const tooltip = document.getElementById('ancient-tooltip');
            document.addEventListener('mouseover', (e) => {
                if (e.target.hasAttribute('data-english')) {
                    tooltip.textContent = e.target.getAttribute('data-english');
                    tooltip.style.opacity = '1';
                }
            });
            document.addEventListener('mousemove', (e) => {
                if (tooltip.style.opacity === '1') {
                    tooltip.style.left = e.clientX + 'px';
                    tooltip.style.top = e.clientY + 'px';
                }
            });
            document.addEventListener('mouseout', (e) => {
                if (e.target.hasAttribute('data-english')) {
                    tooltip.style.opacity = '0';
                }
            });
        }

        // --- ENTITY GENERATORS ---
        function initStars() {
            state.stars = [];
            for (let i = 0; i < 200; i++) {
                state.stars.push({
                    x: Math.random() * state.width,
                    y: Math.random() * (state.height * 0.7),
                    size: Math.random() * 1.5,
                    alpha: Math.random()
                });
            }
        }

        function initClouds() {
            state.clouds = [];
            for (let i = 0; i < 6; i++) {
                state.clouds.push({
                    x: Math.random() * state.width,
                    y: Math.random() * (state.height * 0.3),
                    w: 100 + Math.random() * 200,
                    speed: 0.1 + Math.random() * 0.2
                });
            }
        }

        function initBirds() {
            state.birds = [];
            for (let i = 0; i < 5; i++) {
                state.birds.push({
                    x: Math.random() * state.width,
                    y: 50 + Math.random() * 100,
                    speed: 1 + Math.random() * 1,
                    wingOffset: Math.random() * 10
                });
            }
        }

        function initTorches() {
            state.torches = [
                { xRatio: 0.15, yOffset: -20 },
                { xRatio: 0.25, yOffset: -20 },
                { xRatio: 0.5, yOffset: -100 },
                { xRatio: 0.8, yOffset: -80 },
            ];
        }

        function initHouseholds() {
            state.households = [];
            // Left cluster
            state.households.push({ xRatio: 0.05, w: 40, h: 30, type: 1 });
            state.households.push({ xRatio: 0.08, w: 35, h: 25, type: 2 });
            state.households.push({ xRatio: 0.12, w: 45, h: 35, type: 1 });
            // Right cluster
            state.households.push({ xRatio: 0.88, w: 40, h: 30, type: 1 });
            state.households.push({ xRatio: 0.92, w: 35, h: 25, type: 2 });
            state.households.push({ xRatio: 0.95, w: 50, h: 40, type: 1 });
        }

        // --- UI & SUNDIAL LOGIC ---
        function generateSundialMarks() {
            const svg = document.getElementById('sundial-svg');
            const shadowContainer = document.getElementById('shadow-container');
            const radius = 145;
            const center = 190;
            hourElements = [];

            for (let h = 4; h <= 20; h++) {
                const deg = (h - 12) * 15 - 90;
                const rad = deg * (Math.PI / 180);
                let rom = h === 12 ? 'XII' : toRoman(h > 12 ? h - 12 : h);

                const x1 = center + (radius + 20) * Math.cos(rad);
                const y1 = center + (radius + 20) * Math.sin(rad);
                const x2 = center + (radius + 30) * Math.cos(rad);
                const y2 = center + (radius + 30) * Math.sin(rad);

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", x1); line.setAttribute("y1", y1);
                line.setAttribute("x2", x2); line.setAttribute("y2", y2);
                line.setAttribute("class", "sundial-marks");
                svg.insertBefore(line, shadowContainer);

                const tx = center + (radius) * Math.cos(rad);
                const ty = center + (radius) * Math.sin(rad);

                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", tx); text.setAttribute("y", ty);
                text.setAttribute("class", "sundial-numerals");
                text.textContent = rom;
                hourElements.push({ hour: h, el: text });
                svg.insertBefore(text, shadowContainer);
            }
        }

        function updateSunMarkers() {
            document.querySelectorAll('.sun-event-marker').forEach(el => el.remove());
            const svg = document.getElementById('sundial-svg');
            const shadowContainer = document.getElementById('shadow-container');
            const center = 190; const radius = 145;

            if (!state.sunTimes.rise) return;

            [state.sunTimes.rise, state.sunTimes.set].forEach((date, i) => {
                if (!date) return;
                const h = date.getHours() + date.getMinutes() / 60;
                const deg = (h - 12) * 15 - 90;
                const rad = deg * (Math.PI / 180);
                const isRise = i === 0;
                const label = isRise ? "Sunrise" : "Sunset";
                const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                const color = isRise ? "#ffd700" : "#ff4500";

                const x1 = center + (radius + 15) * Math.cos(rad);
                const y1 = center + (radius + 15) * Math.sin(rad);
                const x2 = center + (radius + 35) * Math.cos(rad);
                const y2 = center + (radius + 35) * Math.sin(rad);

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", x1); line.setAttribute("y1", y1);
                line.setAttribute("x2", x2); line.setAttribute("y2", y2);
                line.setAttribute("stroke", color); line.setAttribute("stroke-width", "4"); line.setAttribute("stroke-linecap", "round");
                line.setAttribute("class", "sun-event-marker hoverable");
                line.setAttribute("data-english", `${label}: ${timeStr}`);
                svg.insertBefore(line, shadowContainer);
            });
        }

        function updateGreeting() {
            const h = state.time.getHours();
            let text = "";
            let translation = "";

            if (h >= 5 && h < 12) { text = "BONVM MANE"; translation = "Good Morning"; }
            else if (h >= 12 && h < 13) { text = "MERIDIES"; translation = "Noon"; }
            else if (h >= 13 && h < 18) { text = "BONVM POMERIDIANVM"; translation = "Good Afternoon"; }
            else if (h >= 18 && h < 22) { text = "BONVM VESPERVM"; translation = "Good Evening"; }
            else { text = "BONAM NOCTEM"; translation = "Good Night"; }

            const el = document.getElementById('greeting-display');
            if (el) {
                el.innerText = text;
                el.setAttribute('data-english', translation);
                el.classList.add('hoverable');
            }
        }

        function updateUI() {
            const now = new Date();
            state.time = now;
            document.getElementById('clock-display').innerText = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });

            updateGreeting();

            const mIndex = now.getMonth();
            const day = now.getDate();
            const year = now.getFullYear();

            const elMonth = document.getElementById('cal-month');
            const elDay = document.getElementById('cal-day');
            const elYear = document.getElementById('cal-year');

            elMonth.textContent = ROMAN_MONTHS[mIndex];
            elDay.textContent = toRoman(day);
            elYear.textContent = toRoman(year);

            elMonth.setAttribute('data-english', now.toLocaleDateString('en-US', { month: 'long' }));
            elDay.setAttribute('data-english', day.toString());
            elYear.setAttribute('data-english', year.toString());

            const h = now.getHours();
            const m = now.getMinutes();
            const timeDec = h + m / 60 + now.getSeconds() / 3600;
            const rotation = ((timeDec - 12) * 15) + 180;

            const shadowContainer = document.getElementById('shadow-container');
            if (shadowContainer) shadowContainer.style.transform = `rotate(${rotation}deg)`;

            const shadowPath = document.getElementById('sun-shadow');
            if (shadowPath) {
                if (timeDec < 5.8 || timeDec > 18.2) shadowPath.style.opacity = "0.15";
                else shadowPath.style.opacity = "0.85";
            }

            hourElements.forEach(item => {
                if (item.hour === h) item.el.classList.add('active-hour');
                else item.el.classList.remove('active-hour');
            });

            const wCode = state.weather.code;
            const wData = WEATHER_MAP[wCode] || { code: "IGNOTA", type: "Unknown", fill: "#333" };

            const liquid = document.getElementById('oracle-liquid');
            const ripple = document.getElementById('rain-ripple');
            const mist = document.getElementById('mist-overlay');
            const text = document.getElementById('oracle-status');
            const tempText = document.getElementById('oracle-temp');

            if (liquid) liquid.style.fill = wData.fill;
            if (text) { text.textContent = wData.code; text.setAttribute('data-english', wData.type); }
            if (tempText) tempText.textContent = state.weather.temp + " 째C";

            if (wData.type === "Rain" || wData.type === "Storm") {
                if (ripple) ripple.style.display = "block"; if (mist) mist.style.display = "none";
            } else if (wData.type === "Fog" || wData.type === "Cloudy") {
                if (ripple) ripple.style.display = "none"; if (mist) mist.style.display = "block";
            } else {
                if (ripple) ripple.style.display = "none"; if (mist) mist.style.display = "none";
            }

            const temp = state.weather.temp;
            const tempLiquid = document.getElementById('temp-liquid');
            const tempBulb = document.getElementById('temp-bulb');

            const minT = -5;
            const maxT = 45;
            const maxH = 190;
            let pct = (temp - minT) / (maxT - minT);
            if (pct < 0) pct = 0; if (pct > 1) pct = 1;

            const hVal = pct * maxH;
            const yVal = 235 - hVal;

            let color = "#d32f2f";
            if (pct < 0.3) color = "#0288d1";
            else if (pct < 0.6) color = "#fbc02d";

            if (tempLiquid) {
                tempLiquid.setAttribute('height', hVal);
                tempLiquid.setAttribute('y', yVal);
                tempLiquid.setAttribute('fill', color);
                tempLiquid.setAttribute('data-english', `${temp}째C`);
            }
            if (tempBulb) {
                tempBulb.setAttribute('fill', color);
                tempBulb.setAttribute('data-english', `${temp}째C`);
            }

            let b = 0.3;
            if (timeDec >= 5 && timeDec < 19) {
                if (timeDec < 7) b = 0.3 + ((timeDec - 5) / 2) * 0.7;
                else if (timeDec > 17) b = 1.0 - ((timeDec - 17) / 2) * 0.7;
                else b = 1.0;
            }

            const instruments = document.querySelector('.instruments-container');
            if (instruments) {
                instruments.style.filter = `drop-shadow(0px 40px 30px rgba(0,0,0,0.8)) brightness(${b})`;
            }
        }

        // --- LANDSCAPE RENDERING ---
        function getGroundY(x) {
            const t = x / state.width;
            if (t < 0.5) {
                return state.height - 50 - (Math.sin(t * Math.PI) * 50);
            }
            else {
                return state.height - 100 + ((t - 0.5) * 40);
            }
        }

        function getDuneY(x, offset, height) {
            return state.height - offset - (Math.sin(x * 0.005) * height) - (Math.cos(x * 0.002) * height / 2);
        }

        function lerpColor(c1, c2, t) {
            const r = Math.round(c1[0] + (c2[0] - c1[0]) * t);
            const g = Math.round(c1[1] + (c2[1] - c1[1]) * t);
            const b = Math.round(c1[2] + (c2[2] - c1[2]) * t);
            return `rgb(${r}, ${g}, ${b})`;
        }

        const SKY_KEYS = {
            night: { top: [0, 0, 0], bottom: [10, 10, 32] },
            dawn: { top: [44, 30, 74], bottom: [214, 93, 69] },
            day: { top: [30, 144, 255], bottom: [135, 206, 235] },
            sunset: { top: [42, 42, 64], bottom: [253, 94, 83] }
        };

        function getSkyColors(timeDec, riseDec, setDec) {
            const preDawn = riseDec - 1.5;
            const postDawn = riseDec + 0.5;
            const preSet = setDec - 1.5;
            const postSet = setDec + 0.5;

            let c1, c2, t;

            if (timeDec < preDawn) return SKY_KEYS.night;
            else if (timeDec < postDawn) {
                t = (timeDec - preDawn) / (postDawn - preDawn);
                c1 = SKY_KEYS.night; c2 = SKY_KEYS.dawn;
                return { topStr: lerpColor(c1.top, c2.top, t), botStr: lerpColor(c1.bottom, c2.bottom, t) };
            } else if (timeDec < riseDec + 2) {
                t = (timeDec - postDawn) / 1.5;
                c1 = SKY_KEYS.dawn; c2 = SKY_KEYS.day;
                return { topStr: lerpColor(c1.top, c2.top, t), botStr: lerpColor(c1.bottom, c2.bottom, t) };
            } else if (timeDec < preSet) return SKY_KEYS.day;
            else if (timeDec < postSet) {
                t = (timeDec - preSet) / (postSet - preSet);
                c1 = SKY_KEYS.day; c2 = SKY_KEYS.sunset;
                return { topStr: lerpColor(c1.top, c2.top, t), botStr: lerpColor(c1.bottom, c2.bottom, t) };
            } else if (timeDec < postSet + 2) {
                t = (timeDec - postSet) / 2;
                c1 = SKY_KEYS.sunset; c2 = SKY_KEYS.night;
                return { topStr: lerpColor(c1.top, c2.top, t), botStr: lerpColor(c1.bottom, c2.bottom, t) };
            } else return SKY_KEYS.night;
        }

        function drawSettlement(isDay) {
            state.households.forEach(house => {
                const x = state.width * house.xRatio;
                const groundY = getGroundY(x);
                const w = house.w;
                const h = house.h;
                const embed = 5;
                ctx.fillStyle = isDay ? "#c2a47c" : "#241812";
                ctx.fillRect(x, groundY - h + embed, w, h);
                ctx.fillStyle = isDay ? "#a1886a" : "#1a120e";
                ctx.fillRect(x - 2, groundY - h + embed - 4, w + 4, 4);
                const windowColor = isDay ? "#4a3b2a" : "rgba(255, 180, 50, 0.6)";
                ctx.fillStyle = isDay ? "#3e2723" : "#100a08";
                ctx.fillRect(x + w / 2 - 5, groundY - 15 + embed, 10, 15);
                if (house.type === 1) {
                    ctx.fillStyle = windowColor;
                    ctx.fillRect(x + 5, groundY - h + 5 + embed, 8, 8);
                    if (!isDay) {
                        ctx.save();
                        ctx.globalCompositeOperation = "lighter";
                        let grad = ctx.createRadialGradient(x + 9, groundY - h + 9 + embed, 1, x + 9, groundY - h + 9 + embed, 15);
                        grad.addColorStop(0, "rgba(255, 150, 20, 0.4)");
                        grad.addColorStop(1, "rgba(0,0,0,0)");
                        ctx.fillStyle = grad;
                        ctx.beginPath(); ctx.arc(x + 9, groundY - h + 9 + embed, 15, 0, Math.PI * 2); ctx.fill();
                        ctx.restore();
                    }
                }
            });
        }

        function drawWeatherFX() {
            fxCtx.clearRect(0, 0, state.width, state.height);

            const wData = WEATHER_MAP[state.weather.code] || {};
            const isRain = (wData.type === "Rain" || wData.type === "Storm");

            if (isRain) {
                // Foreground rain (heavy, fast)
                if (Math.random() > 0.1) {
                    state.rainDrops.push({
                        x: Math.random() * state.width,
                        y: -10,
                        l: Math.random() * 20 + 10,
                        v: Math.random() * 5 + 10,
                        layer: 'fg'
                    });
                }

                fxCtx.strokeStyle = "rgba(174, 194, 224, 0.6)";
                fxCtx.lineWidth = 2;
                fxCtx.beginPath();

                for (let i = state.rainDrops.length - 1; i >= 0; i--) {
                    let d = state.rainDrops[i];
                    if (d.layer !== 'fg') continue;

                    d.y += d.v;
                    fxCtx.moveTo(d.x, d.y);
                    fxCtx.lineTo(d.x, d.y + d.l);

                    if (d.y > state.height) state.rainDrops.splice(i, 1);
                }
                fxCtx.stroke();
            }
        }

        function drawLandscape() {
            ctx.clearRect(0, 0, state.width, state.height);

            const h = state.time.getHours();
            const m = state.time.getMinutes();
            const timeDec = h + m / 60 + state.time.getSeconds() / 3600;

            let riseDec = 6;
            let setDec = 18;
            if (state.sunTimes.rise && state.sunTimes.set) {
                riseDec = state.sunTimes.rise.getHours() + state.sunTimes.rise.getMinutes() / 60;
                setDec = state.sunTimes.set.getHours() + state.sunTimes.set.getMinutes() / 60;
            }

            const isDay = (timeDec >= riseDec && timeDec < setDec);

            const sky = getSkyColors(timeDec, riseDec, setDec);
            let grad = ctx.createLinearGradient(0, 0, 0, state.height);
            const topC = sky.topStr ? sky.topStr : `rgb(${sky.top[0]},${sky.top[1]},${sky.top[2]})`;
            const botC = sky.botStr ? sky.botStr : `rgb(${sky.bottom[0]},${sky.bottom[1]},${sky.bottom[2]})`;
            grad.addColorStop(0, topC);
            grad.addColorStop(1, botC);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, state.width, state.height);

            // Stars
            let starAlpha = 0;
            if (timeDec < riseDec - 0.5 || timeDec > setDec + 0.5) starAlpha = 1;
            else if (timeDec < riseDec + 0.5) starAlpha = 1 - (timeDec - (riseDec - 0.5));
            else if (timeDec > setDec - 0.5) starAlpha = (timeDec - (setDec - 0.5));

            if (starAlpha > 0) {
                ctx.fillStyle = "white";
                state.stars.forEach(s => {
                    ctx.globalAlpha = s.alpha * starAlpha * (Math.random() * 0.5 + 0.5);
                    ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2); ctx.fill();
                });
                ctx.globalAlpha = 1;
            }

            // Background Clouds
            const wType = state.weather.condition;
            if (wType === 'Cloudy' || wType === 'Rain' || wType === 'Storm' || wType === 'Snow') {
                state.clouds.forEach(c => {
                    c.x += c.speed;
                    if (c.x > state.width) c.x = -c.w;
                    ctx.fillStyle = isDay ? "rgba(255, 255, 255, 0.4)" : "rgba(60, 60, 70, 0.3)";
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, 40, 0, Math.PI * 2);
                    ctx.arc(c.x + 30, c.y - 10, 50, 0, Math.PI * 2);
                    ctx.arc(c.x + 60, c.y, 40, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // Distant Rain (Background)
            if (wType === 'Rain' || wType === 'Storm') {
                if (Math.random() > 0.1) {
                    state.rainDrops.push({
                        x: Math.random() * state.width,
                        y: -10,
                        l: Math.random() * 15 + 5,
                        v: Math.random() * 3 + 8,
                        layer: 'bg'
                    });
                }
                ctx.strokeStyle = "rgba(150, 170, 200, 0.3)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let i = state.rainDrops.length - 1; i >= 0; i--) {
                    let d = state.rainDrops[i];
                    if (d.layer !== 'bg') continue;
                    d.y += d.v;
                    ctx.moveTo(d.x, d.y);
                    ctx.lineTo(d.x, d.y + d.l);
                    if (d.y > state.height) state.rainDrops.splice(i, 1);
                }
                ctx.stroke();
            }

            // Sun/Moon
            let cx, cy;
            if (isDay) {
                const dayDuration = setDec - riseDec;
                const prog = (timeDec - riseDec) / dayDuration;
                cx = state.width * prog;
                cy = state.height * 0.9 - Math.sin(prog * Math.PI) * (state.height * 0.75);

                let glow = ctx.createRadialGradient(cx, cy, 10, cx, cy, 80);
                glow.addColorStop(0, "rgba(255, 255, 200, 0.8)");
                glow.addColorStop(1, "rgba(255, 255, 200, 0)");
                ctx.fillStyle = glow; ctx.beginPath(); ctx.arc(cx, cy, 80, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = "#ffeb3b"; ctx.beginPath(); ctx.arc(cx, cy, 20, 0, Math.PI * 2); ctx.fill();
                state.sunPos = { x: cx, y: cy };
            } else {
                const nightDuration = (24 - setDec) + riseDec;
                let moonProg;
                if (timeDec >= setDec) moonProg = (timeDec - setDec) / nightDuration;
                else moonProg = (timeDec + (24 - setDec)) / nightDuration;

                cx = state.width * moonProg;
                cy = state.height * 0.9 - Math.sin(moonProg * Math.PI) * (state.height * 0.75);
                ctx.fillStyle = "#f4f6f0"; ctx.beginPath(); ctx.arc(cx, cy, 18, 0, Math.PI * 2); ctx.fill();
            }

            ctx.fillStyle = isDay ? "#d2b48c" : "#1a120e";
            ctx.beginPath(); ctx.moveTo(0, state.height);
            for (let x = 0; x <= state.width; x += 20) ctx.lineTo(x, getDuneY(x, 80, 40));
            ctx.lineTo(state.width, state.height); ctx.fill();

            ctx.fillStyle = isDay ? "#c2a47c" : "#241812";
            ctx.beginPath(); ctx.moveTo(0, state.height);
            for (let x = 0; x <= state.width; x += 20) ctx.lineTo(x, getDuneY(x + 100, 50, 30));
            ctx.lineTo(state.width, state.height); ctx.fill();

            let lightC = "#e6c288", darkC = "#a1887f";
            if (!isDay) { lightC = "#2c201a"; darkC = "#150f0c"; }
            else if (state.sunPos.x > state.width / 2) { let t = lightC; lightC = darkC; darkC = t; }

            drawPyramid(state.width * 0.5, 350, 220, lightC, darkC);
            drawPyramid(state.width * 0.2, 250, 150, lightC, darkC);
            drawPyramid(state.width * 0.8, 300, 180, lightC, darkC);

            drawRuins(state.width * 0.15, isDay);
            drawRuins(state.width * 0.25, isDay);

            drawSettlement(isDay);

            // Ground
            ctx.fillStyle = isDay ? "#edc988" : "#2e211b";
            ctx.beginPath();
            ctx.moveTo(0, state.height);
            ctx.lineTo(0, getGroundY(0)); // Start at ground level left
            for (let x = 0; x <= state.width; x += 50) ctx.lineTo(x, getGroundY(x));
            ctx.lineTo(state.width, getGroundY(state.width)); // Ensure end point is hit
            ctx.lineTo(state.width, state.height);
            ctx.fill();

            if (!isDay) {
                state.torches.forEach(t => {
                    const tx = state.width * t.xRatio;
                    const ty = getGroundY(tx) + t.yOffset;
                    let grd = ctx.createRadialGradient(tx, ty, 2, tx, ty, 30);
                    grd.addColorStop(0, `rgba(255, 100, 0, ${0.4 + Math.random() * 0.4})`);
                    grd.addColorStop(1, "rgba(255, 0, 0, 0)");
                    ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(tx, ty, 30, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = "#ffcc00"; ctx.beginPath(); ctx.arc(tx, ty, 3, 0, Math.PI * 2); ctx.fill();
                });
            } else {
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 2;
                state.birds.forEach((b, i) => {
                    b.x += b.speed;
                    if (b.x > state.width + 20) b.x = -20;
                    const flap = Math.sin(Date.now() * 0.01 + b.wingOffset) * 5;
                    ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(b.x - 5, b.y - 5 + flap);
                    ctx.moveTo(b.x, b.y); ctx.lineTo(b.x + 5, b.y - 5 + flap); ctx.stroke();
                });
            }
        }

        function drawPyramid(x, w, h, c1, c2) {
            const y = getGroundY(x);
            const embed = 20;
            ctx.beginPath(); ctx.moveTo(x, y - h); ctx.lineTo(x + w / 2, y + embed); ctx.lineTo(x, y + embed); ctx.fillStyle = c2; ctx.fill();
            ctx.beginPath(); ctx.moveTo(x, y - h); ctx.lineTo(x, y + embed); ctx.lineTo(x - w / 2, y + embed); ctx.fillStyle = c1; ctx.fill();
        }

        function drawRuins(x, isDay) {
            const y = getGroundY(x);
            const colColor = isDay ? "#d0c0a0" : "#201814";
            const embed = 10;
            ctx.fillStyle = colColor;
            ctx.fillRect(x, y - 60 + embed, 15, 60); ctx.fillRect(x - 2, y - 65 + embed, 19, 5);
            ctx.fillRect(x + 30, y - 40 + embed, 15, 40);
            ctx.save(); ctx.translate(x + 55, y - 10 + embed); ctx.rotate(0.2); ctx.fillRect(0, 0, 40, 10); ctx.restore();
        }

        async function fetchWeather() {
            const status = document.getElementById('status-msg');
            status.innerText = "Consulting the oracles...";

            let lat = 29.9792;
            let long = 31.1342;

            try {
                const pos = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject);
                });
                lat = pos.coords.latitude;
                long = pos.coords.longitude;
            } catch (e) { }

            try {
                const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${long}&current_weather=true&daily=sunrise,sunset&timezone=auto`;
                const response = await fetch(url);
                const data = await response.json();

                state.weather.code = data.current_weather.weathercode;
                state.weather.temp = data.current_weather.temperature;
                state.weather.isDay = data.current_weather.is_day === 1;
                state.weather.condition = WEATHER_MAP[state.weather.code]?.type || "Clear";

                if (data.daily && data.daily.sunrise) {
                    state.sunTimes.rise = new Date(data.daily.sunrise[0]);
                    state.sunTimes.set = new Date(data.daily.sunset[0]);
                    updateSunMarkers();
                }

                status.innerText = "";
            } catch (e) {
                status.innerText = "Oracles are silent.";
                state.weather.code = 0;
            }
        }

        function gameLoop() {
            updateUI();
            drawLandscape();
            drawWeatherFX();
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>

</html>